from fastapi import APIRouter
from hashlib import sha3_512
from base64 import urlsafe_b64encode, urlsafe_b64decode
from datetime import datetime
from fastapi.responses import JSONResponse
from fastapi.responses import JSONResponse
from fastapi import HTTPException
from api.schemas.ecis import EcisPublicKey

ecis_router = APIRouter(prefix="/pki", tags=["PKI"])


@ecis_router.get("/public_key")
async def get_public_key():
    """
    Retrieve the public key and its SHA3-512 hash.
    The sha3-512 hash is generated by concatenating the public key and the request time.
    To verify the public key, the client can send the exact JSON response back to the server. Read the documentation for more details.
    """
    request_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open("keys/public.pem", "rb") as key_file:
        public_key = key_file.read()
    public_key = urlsafe_b64encode(public_key).decode("utf-8")
    return {
        "key": public_key,
        "sha3_512": sha3_512(f"{public_key}{request_time}".encode()).hexdigest(),
        "request_time": request_time,
    }


@ecis_router.post("/verify_public_key")
async def verify_signature(data: EcisPublicKey):
    """
    Verify the SHA3-512 hash of the public key.
    """
    try:
        with open("keys/public.pem", "rb") as key_file:
            public_key = key_file.read()
        public_key = urlsafe_b64encode(public_key).decode("utf-8")
        server_hash = sha3_512(f"{public_key}{data.request_time}".encode()).hexdigest()
        sha3_512_hash = sha3_512(f"{data.key}{data.request_time}".encode()).hexdigest()

        if (
            sha3_512_hash == data.sha3_512
            and server_hash == data.sha3_512
            and data.key == public_key
        ):
            return JSONResponse(
                status_code=200,
                content={
                    "status": "success",
                    "message": "The integrity of the public key is verified. You can safely use it to encrypt your data.",
                    "public_key": public_key,
                    "request_time": data.request_time,
                },
            )
        else:
            raise HTTPException(
                status_code=400,
                detail="Public key verification failed. The server could not verify the integrity of the requested public key.",
                headers={"WWW-Authenticate": "Bearer"},
            )
    except FileNotFoundError as e:
        return {"status": "error", "message": str(e)}
